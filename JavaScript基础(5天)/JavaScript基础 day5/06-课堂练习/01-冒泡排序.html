<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>冒泡排序</title>
</head>

<body>
    <script>
        // 冒泡排序： 
        // 一种排序算法, 每个元素都跟水里的气泡一样越往上冒体积越大, 最终形成一种从小到大的排序结果.

        // 模拟数据1:
        let moni = [3, 5, 2, 4, 1]
        // 复习数组操作:
        // 1. 数组取值
        moni[0] // 数组名[下标]
        // 2. 数组修改值
        moni[0] = moni[1]
        // console.log(moni) 
        // 3. 交换数组内2个元素的位置
        // 利用第三方变量进行交换(参考交换2个变量的值)

        // -------------------------------------------
        // 模拟数组2:
        let arr = [3, 5, 2, 4, 1]
        // 目的: [1,2,3,4,5]  最大的值在数组的最后

        // 1. 核心思路:
        // 依次比较两个相邻的元素, 如果顺序错误就把它们的位置交换.

        // 2. 代入实现分析:
        // 第一次比较: 3>5 不成立, 则不做操作;        [3, 5, 2, 4, 1]
        // 第二次比较: 5>2 成立,   则交换5和2的位置;  [3, 2, 5, 4, 1]
        // 第三次比较: 5>4 成立,   则交换5和4的位置;  [3, 2, 4, 5, 1]
        // 第四次比较: 5>1 成立,   则交换5和1的位置;  [3, 2, 4, 1, 5]

        // 一轮结束: 实现当前最大值在数组的最后, 但是其他值的顺序依旧错误

        // 3. 代码实现第一轮操作:
        // 1) 因为明确知道循环次数, 所以使用for循环实现
        // 2) 遍历数组
        // 
        // for (let i = 0; i < arr.length; i++) {
        //     // arr[i] 3
        //     // arr[i+1] 5
        //     // 3) 利用if语句, 判断前后相邻的元素大小, 假设第一位比第二位大
        //     if (arr[i] > arr[i + 1]) {
        //         // 4) 如果进入判断语句内部, 就代表顺序错误, 则进行位置交换
        //         let temp = arr[i]
        //         arr[i] = arr[i + 1]
        //         arr[i + 1] = temp
        //     }

        // }

        // // 第一轮结束:
        // console.log(arr) // [3, 2, 4, 1, 5]

        // ------------------------分隔-----------------------------

        // 4. 既然第一轮循环无法实现全部数据的正确排序 => 多跑几次
        // 结论: 利用双重for循环, 重复刚才的对比交换操作

        // 外层循环控制 对比交换的  次数!!!
        // for (let j = 0; j < arr.length; j++) {
        //     // 内层循环控制对比交换的具体操作:
        //     for (let i = 0; i < arr.length; i++) {
        //         if (arr[i] > arr[i + 1]) {
        //             let temp = arr[i]
        //             arr[i] = arr[i + 1]
        //             arr[i + 1] = temp
        //         }
        //     }
        // }

        // console.log(arr) // [1, 2, 3, 4, 5]

        // 5. 优化代码 => 提升性能

        // (1) 分析: 5个数, 需要对比几次?   5个数 两两相比, 比较了4次
        // 在循环次数上进行 -1
        for (let j = 0; j < arr.length - 1; j++) {
            // (2) 分析: 每成功完成一次交换后, 就会有一个最大值放在最后的位置:
            // 例如第一轮完成后, 5就放在了最后, 明知道5是最大的, 4还需要和5进行比较吗?
            // 例如: [3,2,1,4,5] => [2,1,3,4,5] => [1,2,3,4,5] 只需要比较2次即可
            //  利用外层循环次数 j 0 1 2 3 ++的变化, 正好可以用来控制需要少比较的次数
            // arr.length - 1 - j
            for (let i = 0; i < arr.length - 1 - j; i++) {
                if (arr[i] > arr[i + 1]) {
                    let temp = arr[i]
                    arr[i] = arr[i + 1]
                    arr[i + 1] = temp
                }
            }
        }
        
        console.log(arr) // [1, 2, 3, 4, 5]
    </script>
</body>

</html>