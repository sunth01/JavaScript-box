<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 需求: 利用双重for循环实现数组去重!
        // [20, "小明", 30, 40, 30, "小明", "小红", "100", 30]
        // 通过函数处理后变为
        // [20, 40, 30, "小明", "小红", "100"]

        // 1. 不止一种思路, 目前能达到效果即可:
        // 2. 不使用当前阶段超纲的知识点:

        // const a = [1,2,3,4,5,6]
        // console.log(a[3])  // 4
        // a.splice(2,1)
        // console.log(a[3])  // 因为前面少了一位, 可以相同的下标会选中后一位 5
        // // 如果还想输出4怎么办?
        // // 因为前面被删了一位数, 所以下标也需要-1
        // console.log(a[3-1]) // 4

        // 去重铺垫.

        // 最简单的数组去重原理:
        // 双重for循环, 外层控制比较次数, 内层控制比较值, 如果有相同的值, 就在原数组中删除掉
        // 用20和 数组里的每一位元素做比较, 如果找到相同的, 就把它删掉
        // let arr = [20, "小明", 30, 40, 30, "小明", "小红", "100", 30]

        // for (let i = 0; i < arr.length; i++) {
        //     for (let j = i + 1; j < arr.length; j++) {
        //         // 20和小明比较 20和 30比较
        //         // 第三轮时: 30和20比较, 30和小明比较
        //         // 前面对比过, 就没必要继续比较相同的数了, 所以j=i
        //         // 判断语句
        //         // 第一轮:  20和"小明" / 20和30  20和40   20和20
        // console.log(`现在是第${i+1}次比较, 用${arr[i]}和${arr[j]}`)
        //         if (arr[i] === arr[j]) {
        //             // 找到就删掉
        //             console.log(`删掉了${arr[j]}`)
        //             arr.splice(j, 1)
        //             // 重点:
        //             // 原数组被删除了一位, 此时的arr[j] 会有什么变化?
        //             // 会选中后一位元素, 而本次if判断结束后, 会执行j++
        //             // 导致arr[j]的位置, 往后跳了2次
        //             // 中间就漏掉了一次需要对比的元素, 造成漏洞
        //             // 所以需要在删除元素后, 执行(j既然多+1了一次, 那我就-1次)
        //             // j-1 
        //             j--
        //         }
        //     }
        // }

        // console.log(arr)


        // ----------------纯代码版本----------------


        // let arr = [20, "小明", 30, 40, 30, "小明", "小红", "100", 30]

        // for (let i = 0; i < arr.length; i++) {
        //     for (let j = i + 1; j < arr.length; j++) {
        //         if (arr[i] === arr[j]) {
        //             arr.splice(j, 1)
        //             j--
        //         }
        //     }
        // }
        // console.log(arr)

        // 细节优化:
        let arr = [20, "小明", 30, 40, 30, "小明", "小红", "100", 30]
        // 用变量, 把数组长度接收, 后续对比时用的都是len变量
        // 原数组删除后, 长度会自动-1,但是变量不会
        // 所以需要在删除后, 把len-1
        // for (let i = 0, len = arr.length; i < len; i++) {

        //     for (let j = i + 1; j < len; j++) {

        //         if (arr[i] === arr[j]) {
        //             arr.splice(j, 1)
        //             j--
        //             len--
        //         }

        //     }
            
        // }

        // // 每次循环就不用获取数组长度了
        // // for循环时, 获取数组长度, 需要读取arr身上的属性,得到属性值

        // // 去内存里的堆空间找到arr的具体数据再获取长度

        // // 如果用基础数据类型的数字, 来接收数组长度, 只需要执行一次

        // // 后续每次访问len, 去栈空间里访问, 后续每次访问的效率就会高很多

        // // 可以了解, 但是没有比较的写法
        // // 只有在数据量较大时, 能体现出来, 但是!!!
        // // 但是如果数据量较大, 不建议用双重for循环
        // console.log(arr)
    </script>
</body>

</html>